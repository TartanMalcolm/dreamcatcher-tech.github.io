# I11 Request-Idea
![ultimate attribution tree of the cold war internet Photorealistic - Volumetric lighting](/nfts/R11.png)

## Target

[R10 Request-Idea](https://github.com/dreamcatcher-tech/dreamcatcher-tech.github.io/blob/master/website/nfas/Requests/R10.md)

## Inherits

## Dependencies

## Outputs

- [R10](https://github.com/dreamcatcher-tech/dreamcatcher-tech.github.io/blob/master/website/nfas/Requests/R10.md)
- [I11](https://github.com/dreamcatcher-tech/dreamcatcher-tech.github.io/blob/master/website/nfas/Ideas/I11.md)
- [DC Pool Page](https://dreamcatcher-tech.github.io/pool/)
- App Concepts, TBD.
- Complexity count

## Concept
We want to encourage Requests and Ideas to be written down, not matter how vague, as early as possible, then provide a route to move from that vagueness through to having them admitted to a Pool, executed and produce Outputs.  To do this we'd set up areas in git where md files can be placed while in one of three states:  

1. Open: This is the state Requests and Ideas are in before Pool QA have signed them off.  In this state they can be as rough or as complete as you want - no-one's checking.  This the is entry area into the process.   NFTs may (optionally) be generated by the author at any point in this state, one per doc.
	1. State Change Open -> Locked occurs when a Request or Idea passes QA.  NFTs are generated for docs that do not yet have them, and pass QA.
1. Locked: this is the state Requests and Ideas that have passed Pool QA are in before they have been fully executed.  In this state a running total of the time/payments spent to date are tallied.
	1. State Change Locked -> Finalised occurs when the Outputs from an Idea are passed by QA.
1. Finalized: when work has been done on an Idea and the Outputs signed off by QA.  Each sign off would consist of the Request (optionally), the Idea with links to the final Outputs, and a record of the time/payments spent.  NFTs are generated at this stage for Outputs.

A record of these states would be maintained in a file named Market.md which contains a markdown grid of Requests and the Ideas in each state.  For each row we track a tally of the USD pooled funds, and the time expenditure against each one.

The two state changes are controlled by a QA function.  

1. For Open -> Locked: QA is considering whether the Request or Idea adheres to the formatting, and is sufficiently clear in describing a pure problem (Requests) and pure solution (Ideas).  
1. For Locked -> Finalised: QA is considering whether the Outputs from an Idea do actually reflect all of the criteria in the Targetted Request (if there is one), and in the Idea description itself.  I.e. did it do what it said it would do?

To implement the states and state transistions, we'd use two different folders in git, and a pool dashboard (market.md)

1. Requests and Ideas in 'Open' state are in the NFAs folder, and linked from the Open grid in market.md
1. Open -> Locked state change copies the file to the website folder, and moves the link and time/cost data to the Locked grid in market.md
1. Locked -> Finalised state change moves the link and time/cost data to the Finalised grid in market.md

We'd keep the templates for Requests and Ideas in the NFAs folder, and link to them from market.md.  We'd publish the Request/Idea process at the bottom of market.md.

For implementing QA we will use a combination of youtube live streamed calls and pull requests between msm & inv.  Feedback for failed QA attempts is therefore in recorded form rather than documents.  Successful QA attempts are documented by an accepted pull request.

As we don't have a clear idea yet of how much effort, in terms of real money, the Request/Ideas will take and don't have a market to discover what that value should be, we will use pomos as a virtual currency.  By logging pomos against Requests and Ideas we can have a first stab at measuring effort, which can be broadly equated to cash once we've built up some experience recording them as virtual money.


## Actors and Actions

1. QA
	1. Reviews Requests and Ideas against the formats
	1. Records feedback to workers through youtube/voice recording.
	1. Receive PRs for state changes
1. Workers
	1. Write and implement feedback for Requests/Ideas.
	1. Submit PRs for state changes
	1. Produce the Outputs
	1. Log work data
	1. May generate NFTs for their docs.
1. Funders
	1. Pool money against a Request, or an Idea in the Pool.
1. Moderator
	1. Generates NFTs at State Change Open -> Locked if the doc does not already have one.
	1. Updates market.md.
	1. Ensures new Requests/Ideas appear on the website.


## Implementation Steps
1. Write the guidance section in market.md
1. Check and update the Templates, and link them from market.md
1. Populate the data in market.md for any existing Requests/Ideas.
1. Run the integration tests 1-4 on a Request/Idea pair.  This pair will be trivial - we need to test through to Finalised, which involves generating Outputs and two state changes with QA at each, so we will keep it light in order to focus on the integration tests themselves.  
1. Run through each step in that process and check/update that [The User Dictionary](https://dreamcatcher-tech.github.io/docs/) is correct for the terms used.  
2. Run Integration test 5 (Self Improvement) on the notes generated on the process to this point.
3. Create stubs for all existing App Concepts, then run each, one by one, through to Locked.


# Integration Tests
1. Submit a Request:
    1. Submit to State Change Open -> Locked
    1. Have it bounce with QA feedback
    1. Fix the issues
    1. Submit to State Change Open -> Locked QA
    1. Pass QA, and update folders and market.md
1. Submit a Request (as above)
1. Work on Idea Outputs while Locked
    1. Update Idea with links to Outputs
    1. Log work
1. Finalise an Idea 
	1. Submit to State Change Locked -> Finalised QA
	1. Have it bounce with QA feedback
	1. Fix the issues
	1. Submit to State Change Locked -> Finalised QA
	1. Pass QA, and update folders and market.md
1. Self improvement
	1. For notes taken on the Open -> Finalised process
	1. Submit an Idea for the improvement to be made (targetted at [R10]())
	1. Submit to State Change Open -> Locked QA
	1. Pass QA, and update folders and market.md
	1. Carry out the improvement, logging time.
	1. Submit to State Change Locked -> Finalised QA
	1. Pass QA, and update folders and market.md

Done is when the process has passed all three integration tests, [The User Dictionary](https://dreamcatcher-tech.github.io/docs/) has been updated, the complexity count (number of Dictionary concepts used) is known and one cycle of self-improvement has been proven.
